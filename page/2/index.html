<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="chan&#39;s Bloggerrrrr">
<meta property="og:url" content="http:&#x2F;&#x2F;chanchanchan97.github.io&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="chan&#39;s Bloggerrrrr">
<meta property="article:author" content="chan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chanchanchan97.github.io/page/2/"/>





  <title>chan's Bloggerrrrr</title>
  








<meta name="generator" content="Hexo 4.1.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chan's Bloggerrrrr</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Rome was not built in a day.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chanchanchan97.github.io/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chan's Bloggerrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/" itemprop="url">ROS动作通信的编程实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-23T21:13:58+08:00">
                2020-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">ROS机器人操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1.创建功能包"></a>1.创建功能包</h2><p>在ROS工作空间ROS_ws的src文件夹目录下创建一个功能包，命名为action_task。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action1.jpg" class=""></p>
<h2 id="2-节点编程与动作消息定义"><a href="#2-节点编程与动作消息定义" class="headerlink" title="2.节点编程与动作消息定义"></a>2.节点编程与动作消息定义</h2><h3 id="2-1案例说明"><a href="#2-1案例说明" class="headerlink" title="2.1案例说明"></a>2.1案例说明</h3><p>客户端发送一个运动目标，模拟机器人运动到目标位置的过程，包含服务端和客户端的代码实现，要求带有实时位置反馈。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action2.jpg" class=""></p>
<h3 id="2-2动作消息的定义"><a href="#2-2动作消息的定义" class="headerlink" title="2.2动作消息的定义"></a>2.2动作消息的定义</h3><p>在功能包目录下创建一个新的文件夹，命名为action，并在此文件夹中创建一个空文件Motion.action。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action3.jpg" class=""><br>在Motion.action文件中输入以下代码，定义动作消息内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义机器人运动终点坐标endx，endy</span><br><span class="line">uint32 endx</span><br><span class="line">uint32 endy</span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F;定义机器人动作完成标志位</span><br><span class="line">uint32 Flag_Finished</span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F;定义机器人当前位置坐标coordinate_x，coordinate_y</span><br><span class="line">uint32 coordinate_x</span><br><span class="line">uint32 coordinate_y</span><br></pre></td></tr></table></figure><br>说明：<br>动作（Action）通信接口提供了五种消息定义，分别为goal、cancel、status、feedback和result，而.action文件用来定义其中三种消息，按顺序分别为goal、result和feedback，与.srv文件中的服务消息定义方式一样，使用“—-”作为分隔符。<br>Motion.action文件经过编译后生成MotionAction.h、MotionActionFeedback.h和MotionGoal.h等多个头文件，文件位置在ROS_ws工作空间下的devel/include/action_task文件夹内，如下图。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action4.jpg" class=""><br>附相关资料：<a href="http://wiki.ros.org/actionlib#Tutorials" target="_blank" rel="noopener">http://wiki.ros.org/actionlib#Tutorials</a></p>
<h3 id="2-3创建-cpp文件"><a href="#2-3创建-cpp文件" class="headerlink" title="2.3创建.cpp文件"></a>2.3创建.cpp文件</h3><p>在功能包下面的action文件夹目录下创建一个空文件robotclient.cpp。</p>
<h3 id="2-4动作客户端编程"><a href="#2-4动作客户端编程" class="headerlink" title="2.4动作客户端编程"></a>2.4动作客户端编程</h3><p>打开上面所创建的文件robotclient.cpp，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros&#x2F;ros.h&gt;</span><br><span class="line">#include &lt;actionlib&#x2F;client&#x2F;simple_action_client.h&gt;</span><br><span class="line">#include &quot;action_task&#x2F;MotionAction.h&quot;</span><br><span class="line"></span><br><span class="line">typedef actionlib::SimpleActionClient&lt;action_task::MotionAction&gt; Client;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当动作完成后，调用该回调函数一次</span><br><span class="line">void doneCb(const actionlib::SimpleClientGoalState&amp; state,</span><br><span class="line">	    const action_task::MotionResultConstPtr&amp; result)</span><br><span class="line">&#123;</span><br><span class="line">	ROS_INFO(&quot;The robot has arrived at the destination.&quot;);</span><br><span class="line">	ros::shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当动作被激活，调用该函数一次</span><br><span class="line">void activeCb()</span><br><span class="line">&#123;</span><br><span class="line">	ROS_INFO(&quot;Goal just went active&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收到feedback后，调用该回调函数</span><br><span class="line">void feedbackCb(const action_task::MotionFeedbackConstPtr&amp; feedback)</span><br><span class="line">&#123;</span><br><span class="line">	ROS_INFO(&quot; The place of robot : (%d , %d) &quot;, feedback-&gt;coordinate_x, feedback-&gt;coordinate_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;初始化ROS节点</span><br><span class="line">	ros::init(argc, argv, &quot;robot_client&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建一个action客户端</span><br><span class="line">	Client client(&quot;robot_motion&quot;, true);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;等待action服务器响应</span><br><span class="line">	ROS_INFO(&quot;Waiting for action server to start.&quot;);</span><br><span class="line">	client.waitForServer();</span><br><span class="line">	ROS_INFO(&quot;Action server started, sending goal.&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建一个action目标</span><br><span class="line">	action_task::MotionGoal goal;</span><br><span class="line">	goal.endx &#x3D; 5;</span><br><span class="line">	goal.endy &#x3D; 4;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;发送action目标给服务器，并设置回调函数</span><br><span class="line">	client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span><br><span class="line"></span><br><span class="line">	ros::spin();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明：<br>◆头文件actionlib/client/simple_action_client.h用于实现简单的动作客户端。其中actionlib软件包提供了创建执行长期目标的服务器，以及一个客户端接口，以便将请求发送到服务器。<br>◆头文件action_task/MotionAction.h是由Motion.action文件编译生成，定义了动作消息内容，该文件存放在ROS_ws工作空间下的devel/include/action_task文件夹中。<br>◆typedef actionlib::SimpleActionClient<action_task::MotionAction> Client;的作用是使用Client声明定义action_task::MotionAction类型的actionlib::SimpleActionClient类。<br>◆doneCb(const actionlib::SimpleClientGoalState&amp; state, const action_task::MotionResultConstPtr&amp; result)该函数在服务器完成任务后，通知客户端调用一次，调用该回调函数后ROS系统在终端界面输出字符串”The robot has arrived at the destination.”表明动作完成，同时ros::shutdown()关闭客户端节点，终止所有开放的订阅，发布，服务及调用。<br>◆void activeCb()该函数是在动作服务器被激活后，通知客户端开始执行任务的回调函数，调用该回调函数后ROS系统在终端界面输出字符串”Goal just went active”表明action被激活。<br>◆void feedbackCb(const action_task::MotionFeedbackConstPtr&amp; feedback)该函数是在动作服务器执行任务过程中，通知客户端机器人当前坐标的回调函数。const action_task::MotionFeedbackConstPtr&amp; feedback这里存放的是由主调函数放进来的实参变量feedback的地址，通过引用传递给回调函数。调用该回调函数后ROS系统在终端界面输出当前机器人位置的横纵坐标。<br>◆main函数中首先使用ros::init()初始化ROS节点，将该节点命名为robot_client。<br>◆Client client(“robot_motion”, true);的作用是创建一个action_task::MotionAction类型的action客户端。Client是之前已经使用typedef重新声明定义的actionlib::SimpleActionClient<action_task::MotionAction>，client是一个action_task::MotionAction消息类型的对象，第一个参数表示action客户端与服务器之间通信的消息名称，第二个参数true表示action客户端以单线程运行。<br>◆client.waitForServer()函数的作用是等待客户端连接到动作服务器，否则客户端将停在这里一直处于等待，不过也可以使用ros::duration()函数作为参数设置等待时间。<br>◆action_task::MotionGoal goal是创建一个action_task::MotionGoal类的对象goal，并为goal成员endx、endy即终点坐标赋值。<br>◆client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);的作用是发送一个目标值到action服务器，并设置多个回调函数检测goal的执行情况（action服务器和客户端分别在接收和发送goal之后会通过状态机追踪goal的状态，并采取相应的处理）。<br>◆ros::spin();的作用是让程序进入自循环的挂起状态，从而让程序以最好的效率接收客户端的请求并调用回调函数。  </p>
<h2 id="2-5action服务器编程"><a href="#2-5action服务器编程" class="headerlink" title="2.5action服务器编程"></a>2.5action服务器编程</h2><p>在src文件夹下再创建一个空文件robotserver.cpp，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros&#x2F;ros.h&gt;</span><br><span class="line">#include &lt;actionlib&#x2F;server&#x2F;simple_action_server.h&gt;</span><br><span class="line">#include &quot;action_task&#x2F;MotionAction.h&quot;</span><br><span class="line"></span><br><span class="line">#define wid 5</span><br><span class="line">#define hig 5</span><br><span class="line"></span><br><span class="line">typedef actionlib::SimpleActionServer&lt;action_task::MotionAction&gt; Server;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义结构体</span><br><span class="line">struct note</span><br><span class="line">&#123;</span><br><span class="line">	int x;&#x2F;&#x2F;横坐标</span><br><span class="line">	int y;&#x2F;&#x2F;纵坐标</span><br><span class="line">	int f;&#x2F;&#x2F;父节点在队列中的编号</span><br><span class="line">	int s;&#x2F;&#x2F;步数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收到action的goal之后，调用该回调函数一次</span><br><span class="line">void execute(const action_task::MotionGoalConstPtr&amp; goal, Server* as)</span><br><span class="line">&#123;</span><br><span class="line">	struct note que[40];&#x2F;&#x2F;定义一个note结构体的队列</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;定义地图大小及形式，1为障碍物，0为正常道路</span><br><span class="line">	int map[6][6]&#x3D;&#123;&#123;0, 0, 1, 0, 0, 1&#125;,</span><br><span class="line">					 &#123;1, 0, 1, 0, 0, 0&#125;,</span><br><span class="line">					 &#123;1, 0 ,0, 1, 0, 1&#125;,</span><br><span class="line">				  	 &#123;0, 1, 0, 0, 0, 0&#125;,</span><br><span class="line">				  	 &#123;0, 0, 0, 1, 1, 0&#125;,</span><br><span class="line">				  	 &#123;1, 0, 0, 1, 0, 0&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;记录哪些点已经在队列中，防止一个点被重复扩展			   </span><br><span class="line">	int book[6][6]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;定义一个表示走的方向的数组</span><br><span class="line">	int next[4][2]&#x3D;&#123;&#123;0,1&#125;, &#x2F;&#x2F;向右</span><br><span class="line">			         &#123;1,0&#125;, &#x2F;&#x2F;向下</span><br><span class="line">					  &#123;0,-1&#125;,&#x2F;&#x2F;向左</span><br><span class="line">					 &#123;-1,0&#125;&#125;;&#x2F;&#x2F;向上</span><br><span class="line"></span><br><span class="line">	int head, tail;</span><br><span class="line">	int j, k, l;</span><br><span class="line">	int startx &#x3D; 0, starty &#x3D; 0;</span><br><span class="line">	int p,q,tx,ty,flag;</span><br><span class="line"></span><br><span class="line">	ros::Rate r(1); &#x2F;&#x2F;设置ROS系统延时频率</span><br><span class="line">	</span><br><span class="line">	action_task::MotionFeedback feedback; &#x2F;&#x2F;创建一个feedback对象</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;初始化队列</span><br><span class="line">	head&#x3D;0;&#x2F;&#x2F;head point to the point needed to expand</span><br><span class="line">	tail&#x3D;0;&#x2F;&#x2F;tail point to the point expanded</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F;定义起点坐标</span><br><span class="line">	que[tail].x&#x3D;startx;</span><br><span class="line">	que[tail].y&#x3D;starty;</span><br><span class="line">	que[tail].f&#x3D;0;</span><br><span class="line">	que[tail].s&#x3D;0;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty]&#x3D;1;</span><br><span class="line">    </span><br><span class="line">	flag&#x3D;0;&#x2F;&#x2F;用来标记是否到达目标点，0表示还没有到达，1表示已到达</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;当队列不为空时循环</span><br><span class="line">	while(head&lt;tail)	</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;枚举四个方向</span><br><span class="line">		for(k&#x3D;0;k&lt;&#x3D;3;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;计算下一个点的坐标</span><br><span class="line">			tx&#x3D;que[head].x+next[k][0];</span><br><span class="line">			ty&#x3D;que[head].y+next[k][1];</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;判断是否越界</span><br><span class="line">			if(tx&lt;0 || tx&gt;wid || ty&lt;0 || ty&gt;hig)</span><br><span class="line">				continue;</span><br><span class="line">			&#x2F;&#x2F;判断是否为障碍物或已经在路径中</span><br><span class="line">			if(map[tx][ty]&#x3D;&#x3D;0 &amp;&amp; book[tx][ty]&#x3D;&#x3D;0)</span><br><span class="line">			&#123;	</span><br><span class="line">				&#x2F;&#x2F;标记这个点已经被走过</span><br><span class="line">				book[tx][ty]&#x3D;1;</span><br><span class="line">				&#x2F;&#x2F;插入新的坐标到队列中</span><br><span class="line">				que[tail].x&#x3D;tx;</span><br><span class="line">				que[tail].y&#x3D;ty;</span><br><span class="line">				que[tail].f&#x3D;head;</span><br><span class="line">				que[tail].s&#x3D;que[head].s+1;</span><br><span class="line">				tail++;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			feedback.coordinate_x &#x3D; tx;</span><br><span class="line">			feedback.coordinate_y &#x3D; ty;</span><br><span class="line">			as-&gt;publishFeedback(feedback);&#x2F;&#x2F;按照1Hz的频率发送机器人当前坐标位置</span><br><span class="line">			r.sleep();&#x2F;&#x2F;延时至1s</span><br><span class="line">            </span><br><span class="line">			if(tx&#x3D;&#x3D;goal-&gt;endx &amp;&amp; ty&#x3D;&#x3D;goal-&gt;endy)</span><br><span class="line">			&#123;</span><br><span class="line">				flag&#x3D;1;&#x2F;&#x2F;到达目标点后标志位flag置1</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		if(flag&#x3D;&#x3D;1)</span><br><span class="line">			break;</span><br><span class="line">		head++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;表示已经发送成功</span><br><span class="line">	as-&gt;setSucceeded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;初始化ROS节点</span><br><span class="line">	ros::init(argc, argv, &quot;robot_server&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建节点句柄</span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建一个action服务器</span><br><span class="line">	Server server(n, &quot;robot_motion&quot;, boost::bind(&amp;execute, _1, &amp;server), false);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;启动action服务器</span><br><span class="line">	server.start();</span><br><span class="line">	</span><br><span class="line">	ros::spin();</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明：<br>◆头文件ros/ros.h包含了标准ROS类的声明，在每一个ROS程序中都需要包含它。<br>◆头文件actionlib/server/simple_action_server.h用于实现简单的动作服务端。<br>◆头文件action_task/MotionAction.h    是由Motion.action文件编译生成，定义了动作消息内容，该文件存放在ROS_ws工作空间下的devel/include/action_task文件夹中。<br>◆typedef actionlib::SimpleActionServer<action_task::MotionAction> Server;的作用是使用Server声明定义action_task::MotionAction类型的actionlib::SimpleActionServer类。<br>◆void execute(const action_task::MotionGoalConstPtr&amp; goal, Server<em> as)当action服务器接收到客户端的goal时调用该回调函数。其中第一个参数是通过引用向回调函数传递的指向goal的指针，goal的消息类型为action_task::MotionGoal，第二个参数是actionlib::SimpleActionServer类的指针as，消息类型为action_task::MotionAction。<br>◆在execute()回调函数中通过建立一个6×6的数组模拟机器人运行的地图，根据action客户端发来的goal目标点坐标，使用广度优先搜索算法寻找可运行的路径，服务器按照1Hz频率发布feedback。<br>◆ros::Rate r(1);的作用是设置feedback发布频率为1Hz。<br>◆action_task::MotionFeedback feedback;的作用是创建一个action_task::MotionFeedback类的对象feedback。<br>◆as-&gt;publishFeedback(feedback);调用指针as指向的actionlib::SimpleActionServer类所包含的publishFeedback()函数，publishFeedback (const Feedback &amp;feedback)函数用于发布feedback。<br>◆r.sleep();该函数并不是必要的，这里的作用是为了延时，让服务器保证以1Hz的频率发布feedback。<br>◆as-&gt;setSucceeded();调用指针as指向的actionlib::SimpleActionServer类所包含的setSucceeded ()函数，setSucceeded (const Result &amp;result=Result(), const std::string &amp;text=std::string(“”))函数中第一个参数表示动作执行任务的结果result，默认为0，第二个参数是有关状态更改的文本消息，两个参数均可省略。<br>◆main函数中一开始都是类似的，初始化ROS节点，创建节点句柄，从而启动ROS节点。<br>◆Server server(n, “robot_motion”, boost::bind(&amp;execute, _1, &amp;server), false);的作用是创建一个action服务器，其中第一个参数表示所创建节点句柄名；第二个参数表示服务器与客户端之间通信的消息名；第三个参数表示所要调用的回调函数，当接收到新的goal后，就会在单独的线程中调用该回调函数。boost::bind()函数用来向一个函数(或函数对象)绑定某些参数，返回值是一个函数对象，其中第一个参数是需要绑定的原始函数的地址，此处为&amp;execute，第二个参数是需要绑定到原始函数excute()的第一个参数值，而此处_1表示execute(const action_task::MotionGoalConstPtr&amp; goal, Server</em> as)函数的第一个参数不需要绑定，因此使用_1占位，第三个参数是需要绑定到原始函数excute()的第二个参数值，此处为&amp;server表示将server对象的地址绑定到execute()函数中的Server* as指针。server(n, “robot_motion”, boost::bind(&amp;execute, _1, &amp;server), false)中的第四个参数是一个bool值，它的作用是通知action服务器是否在被创建后立即开始发布，此参数应当始终设置为false，并且在服务器被创建后调用start()。<br>◆server.start();的作用是启动action服务器，使用时需保证创建action服务器时第四个参数auto_start设置为false。<br>◆ros::spin();的作用是让程序进入自循环的挂起状态，从而让程序以最好的效率接收客户端的请求并调用回调函数。<br>附相关资料：<br>1.<a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/SimpleActionServer%28ExecuteCallbackMethod%29" target="_blank" rel="noopener">http://wiki.ros.org/actionlib_tutorials/Tutorials/SimpleActionServer%28ExecuteCallbackMethod%29</a><br>2.<a href="https://docs.ros.org/diamondback/api/actionlib/html/classactionlib_1_1SimpleActionServer.html" target="_blank" rel="noopener">https://docs.ros.org/diamondback/api/actionlib/html/classactionlib_1_1SimpleActionServer.html</a><br>3.<a href="http://docs.ros.org/melodic/api/actionlib/html/classactionlib_1_1ServerGoalHandle.html#ac297923512ac62c9f10a801571b29738" target="_blank" rel="noopener">http://docs.ros.org/melodic/api/actionlib/html/classactionlib_1_1ServerGoalHandle.html#ac297923512ac62c9f10a801571b29738</a></p>
<h2 id="3-配置与编译"><a href="#3-配置与编译" class="headerlink" title="3.配置与编译"></a>3.配置与编译</h2><h3 id="3-1在CMaKeLists-txt中添加编译选项"><a href="#3-1在CMaKeLists-txt中添加编译选项" class="headerlink" title="3.1在CMaKeLists.txt中添加编译选项"></a>3.1在CMaKeLists.txt中添加编译选项</h3><p>打开功能包中的CMaKeLists.txt文件，在如下位置的find_package中添加功能包actionlib和actionlib_msgs，以便于（节点）调用它们生成消息。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action5.jpg" class=""><br>在如下位置添加相关的.action文件，确保了CMake在重新配置时知道这些新添加的.action文件，同时添加.action文件在生成消息时的所有依赖项（功能包）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_action_files(DIRECTORY action FILES Motion.action)</span><br><span class="line"></span><br><span class="line">generate_messages(DEPENDENCIES actionlib_msgs std_msgs)</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action6.jpg" class=""><br>将如下位置中CATLIN_DEPENDS前面的“#”去掉，使能相关的依赖项。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action7.jpg" class=""><br>在如下位置进行配置，add_executable(robotclient src/robotclient.cpp)的作用是将src文件夹下的robotclient.cpp文件编译成名为robotclient的可执行文件。target_link_libraries(robotclient ${catkin_LIBRARIES})的作用是将robotclient可执行文件与ROS相关的库链接。add_dependencies(robotclient ${${PROJECT_NAME}_EXPORTED_TARGETS})的作用是创建一个显式的依赖，以便相关文件能以正确的顺序编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_executable(robotclient src&#x2F;robotclient.cpp)</span><br><span class="line">target_link_libraries(robotclient $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(robotclient $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(robotserver src&#x2F;robotserver.cpp)</span><br><span class="line">target_link_libraries(robotserver $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(robotserver $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action8.jpg" class=""></p>
<h3 id="3-2在package-xml中添加功能包依赖"><a href="#3-2在package-xml中添加功能包依赖" class="headerlink" title="3.2在package.xml中添加功能包依赖"></a>3.2在package.xml中添加功能包依赖</h3><p>打开功能包中的package.xml文件，在如下位置添加功能包依赖。&#60;build_depend&#62;actionlib&#60;/build_depend&#62;表示在编译时会依赖actionlib功能包。&#60;exec_depend&#62;actionlib&#60;/exec_depend&#62;表示在运行时会依赖actionlib功能包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;actionlib&lt;&#x2F;build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;actionlib_msgs&lt;&#x2F;build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;actionlib&lt;&#x2F;exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;actionlib_msgs&lt;&#x2F;exec_depend&gt;</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action9.jpg" class=""></p>
<h3 id="3-3编译文件"><a href="#3-3编译文件" class="headerlink" title="3.3编译文件"></a>3.3编译文件</h3><p>在/ROS_ws文件夹路径下打开一个新的终端，输入以下代码进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action10.jpg" class=""><br>编译完成后，输入以下代码运行主节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action11.jpg" class=""><br>打开一个新的终端，配置环境变量后，输入以下代码运行客户端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun action_task robotclient</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action12.jpg" class=""><br>打开一个新的终端，配置环境变量后，输入以下代码运行服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun action_task robotserver</span><br></pre></td></tr></table></figure><br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action13.jpg" class=""><br>若想停止运行，关闭终端，使用快捷键Ctrl+c即可。</p>
<h2 id="4-话题可视化"><a href="#4-话题可视化" class="headerlink" title="4.话题可视化"></a>4.话题可视化</h2><p>打开一个新的终端，在action服务器及客户端运行时输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rqt_graph</span><br></pre></td></tr></table></figure><br>由此可以得到如下的基于Qt的GUI界面，直观地看到动作通信的节点和消息。<br><img src="/2020/03/23/ROS%E5%8A%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/action14.jpg" class=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chanchanchan97.github.io/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chan's Bloggerrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/" itemprop="url">ROS服务通信的编程实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-12T00:23:31+08:00">
                2020-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">ROS机器人操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1.创建功能包"></a>1.创建功能包</h2><p>在ROS工作空间ROS_ws的src文件夹目录下创建一个功能包，命名为communication_pkg，并编译完成。<br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service1.jpg" class=""></p>
<h2 id="2-节点编程与服务数据定义"><a href="#2-节点编程与服务数据定义" class="headerlink" title="2.节点编程与服务数据定义"></a>2.节点编程与服务数据定义</h2><h3 id="2-1案例说明"><a href="#2-1案例说明" class="headerlink" title="2.1案例说明"></a>2.1案例说明</h3><p>定义一个客户端Client，通过自定义的服务请求Request将两个整数发送给服务器Server，同时服务器Server将两个整数相加后，再通过自定义的服务应答Response将两个整数的和反馈到客户端Client。<br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service2.jpg" class=""></p>
<h3 id="2-2服务数据的定义"><a href="#2-2服务数据的定义" class="headerlink" title="2.2服务数据的定义"></a>2.2服务数据的定义</h3><p>在功能包目录下创建一个新的文件夹，命名为srv，并在此文件夹中创建一个空文件AddTwoInts.srv。<br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service3.jpg" class=""><br>在AddTwoInts.srv文件中输入以下代码，定义服务消息内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><br>说明：<br>使用“—-”作为分隔符，“—-”上面代表服务请求的消息内容，“—-”下面代表服务应答的消息内容。<br>相关资料：<a href="https://wiki.ros.org/srv" target="_blank" rel="noopener">https://wiki.ros.org/srv</a></p>
<h3 id="2-3创建-cpp文件"><a href="#2-3创建-cpp文件" class="headerlink" title="2.3创建.cpp文件"></a>2.3创建.cpp文件</h3><p>在功能包下面的src文件夹目录下创建一个空文件client.cpp。</p>
<h3 id="2-4客户端编程"><a href="#2-4客户端编程" class="headerlink" title="2.4客户端编程"></a>2.4客户端编程</h3><p>打开上面所创建的文件client.cpp，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &quot;ros&#x2F;ros.h&quot;</span><br><span class="line">#include &quot;communication_pkg&#x2F;AddTwoInts.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;初始化ROS节点</span><br><span class="line">	ros::init(argc, argv, &quot;add_two_ints_client&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;从终端获取数据</span><br><span class="line">	if(argc !&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		ROS_INFO(&quot;usage: add_two_ints_client X Y&quot;);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建句柄</span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建一个客户端，定义服务请求数据类型communication_pkg::AddTwoInts</span><br><span class="line">	ros::ServiceClient client &#x3D; n.serviceClient&lt;communication_pkg::AddTwoInts&gt;(&quot;add_two_ints&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;定义服务消息内容</span><br><span class="line">	communication_pkg::AddTwoInts srv;</span><br><span class="line">	srv.request.a &#x3D; atoll(argv[1]);</span><br><span class="line">	srv.request.b &#x3D; atoll(argv[2]);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;发布服务请求，等待应答结果</span><br><span class="line">	if(client.call(srv))</span><br><span class="line">	&#123;</span><br><span class="line">		ROS_INFO(&quot;Sum: %ld&quot;, (long int)srv.response.sum);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		ROS_ERROR(&quot;Failed to call service add_two_ints&quot;);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明：<br>◆头文件cstdlib.h是C++里面的一个常用函数库，等价于C中的stdlib.h，可以提供一些函数与符号常量。<br>◆头文件ros/ros.h包含了标准ROS类的声明，在每一个ROS程序中都需要包含它。<br>◆头文件communication_pkg/AddTwoInts.h是由AddTwoInts.srv编译扩展得到，包含了针对C++类的定义等，它存放在工作空间的devel/include路径下的communication_pkg文件夹中。<br>◆int main(int argc, char &#42;&#42;argv)是main函数的一种定义形式，其参数argc和argv用于运行时,把命令行参数传入主程序，其中arg是指arguments，即参数。<br>(1)int argc：英文名为arguments count（参数计数），表示运行程序传送给main函数的命令行参数总个数,包括可执行程序名,其中当argc=1时表示只有一个程序名称,此时存储在argv[0]中。<br>(2) char &#42;&#42;argv：英文名为arguments value/vector（参数值），用来存放指向字符串参数的指针数组，每个元素指向一个参数，空格分隔参数，其长度为argc。数组下标从0开始，argv[argc]=NULL。argv[0]指向程序运行时的全路名；argv[1]指向程序在DOS命令中执行程序名后的第一个字符串；argv[2]指向执行程序名后的第二个字符串。<br>◆ros::init(argc, argv, “add_two_ints_client”)的作用是初始化ROS节点，第三个参数表示节点名称，这个节点名是唯一的。<br>◆if(argc != 3){…}表示当终端命令行输入的参数数量不等于3，则执行这段代码。<br>◆ros::NodeHandle n;的作用是创建句柄，启动ROS节点。<br>◆ros::ServiceClient client = n.serviceClient<communication_pkg::AddTwoInts>(“add_two_ints”);这是用户调用ROS服务的其中一种方法。它创建了一个客户端，其返回的ros::ServiceClient类的对象client之后将用于向ROS网络中名为add_two_ints的节点发送服务请求，服务请求的数据类型为communication_pkg::AddTwoInts。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">communication_pkg::AddTwoInts srv;</span><br><span class="line">srv.request.a &#x3D; atoll(argv[1]);</span><br><span class="line">srv.request.b &#x3D; atoll(argv[2]);</span><br></pre></td></tr></table></figure><br>◆这是创建服务请求和服务应答的其中一种方法。它定义了一个service_example::AddTwoInts类型的对象，该对象中的成员正是srv文件中定义的a、b、sum，将终端命令行输入的两个数填充到数据成员a、b中。atoll()函数的作用是将字符串转换成长长整型数(long long int)，即srv.request.a = atoll(argv[1])是将命令行输入的字符串中的第一个数转换成长长整型数，并赋值给成员a，srv.request.b = atoll(argv[2])则同理。<br>◆if(client.call(srv)){…}表示向ROS网络发起服务请求。由于服务请求处于阻塞状态，需要等待请求发起完成后才能返回值。如果服务调用成功，则call()将返回true，并且srv.response中的值将有效。如果调用失败，则call()将返回false，并且srv.response中的值将无效。<br>◆ROS_INFO()和ROS_ERROR()用于输出日志信息，日志消息分为五个不同的严重级别，按照严重性程度递增，分别为DEBUG、INFO、WARN、ERROR、FATAL。<br>综上所述，实现一个客户端的步骤大致可分为以下几点：<br>(1)初始化ROS节点；<br>(2)创建client实例；<br>(3)发布服务请求数据；<br>(4)等待Server处理之后的应答结果。  </p>
<h3 id="2-5服务器编程"><a href="#2-5服务器编程" class="headerlink" title="2.5服务器编程"></a>2.5服务器编程</h3><p>在src文件夹下再创建一个空文件server.cpp，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros&#x2F;ros.h&quot;</span><br><span class="line">#include &quot;communication_pkg&#x2F;AddTwoInts.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务回调函数，输入为服务请求Req，输出为服务应答Res</span><br><span class="line">bool add(communication_pkg::AddTwoInts::Request  &amp;req,</span><br><span class="line">	 communication_pkg::AddTwoInts::Response &amp;res)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;将两个数相加，并将结果存放在变量sum中</span><br><span class="line">res.sum &#x3D; req.a + req.b;</span><br><span class="line">ROS_INFO(&quot;request: x&#x3D;%ld, y&#x3D;%ld&quot;, (long int)req.a, (long int)req.b);</span><br><span class="line">ROS_INFO(&quot;sending back response: [%ld]&quot;, (long int)res.sum);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;初始化ROS节点</span><br><span class="line">	ros::init(argc, argv, &quot;add_two_ints_server&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建句柄</span><br><span class="line">	ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建服务器，登记回调函数</span><br><span class="line">	ros::ServiceServer service &#x3D; n.advertiseService(&quot;add_two_ints&quot;, add);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;循环等待</span><br><span class="line">	ROS_INFO(&quot;Ready to add two ints.&quot;);</span><br><span class="line">	ros::spin();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明：<br>◆main函数中一开始都是类似的，初始化ROS节点，创建句柄，从而启动ROS节点。<br>◆ros::ServiceServer service = n.advertiseService(“add_two_ints”, add);的作用是创建服务，并将服务加入到ROS网络中。这个服务在ROS网络中以add_two_ints命名，并且作为唯一标识，以便于其他节点通过服务名称进行请求。当接收到服务请求后，则调用add()回调函数。<br>◆ros::spin()的作用是让程序进入自循环的挂起状态，从而让程序以最好的效率接收客户端的请求并调用回调函数。<br>◆服务回调函数的表示形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool callback(MReq &amp;request, MRes &amp;response)</span><br></pre></td></tr></table></figure><br>其中MReq和MRes与提供给advertiseService()的请求/应答的数据类型相匹配。回调函数的返回值若为true，则表示服务请求成功，并且服务应答已填充必要的数据。若返回值为false则表示服务请求失败，并且服务应答将不会发送给客户端。<br>◆回调函数add(communication_pkg::AddTwoInts::Request  &amp;req, communication_pkg::AddTwoInts::Response &amp;res)的作用是实现两个int型整数求和的服务，两个整数从request获取，求和结果填充到response里，request与response的具体数据类型在srv文件中被定义。<br>综上所述，实现一个服务器的步骤大致可分为以下几点：<br>(1)初始化ROS节点；<br>(2)创建Server实例；<br>(3)循环等待服务请求，进入回调函数；<br>(4)在回调函数中完成服务功能的处理，并反馈应答数据。<br>附相关资料：<br>(1)<a href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29" target="_blank" rel="noopener">http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29</a><br>(2)<a href="http://wiki.ros.org/roscpp/Overview/Services" target="_blank" rel="noopener">http://wiki.ros.org/roscpp/Overview/Services</a></p>
<h2 id="3-配置与编译"><a href="#3-配置与编译" class="headerlink" title="3.配置与编译"></a>3.配置与编译</h2><h3 id="3-1在CMaKeLists-txt中添加编译选项"><a href="#3-1在CMaKeLists-txt中添加编译选项" class="headerlink" title="3.1在CMaKeLists.txt中添加编译选项"></a>3.1在CMaKeLists.txt中添加编译选项</h3><p>打开功能包中的CMaKeLists.txt文件，在如下位置的find_package中添加功能包，以便于（节点）调用它们生成消息。<br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service4.jpg" class=""><br>在如下位置添加相关的.srv文件，确保了CMake在重新配置时知道这些新添加的.srv文件，同时添加.srv文件在生成消息时的所有依赖项（功能包）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(FILES AddTwoInts.srv)</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service5.jpg" class=""><br>将如下位置中CATLIN_DEPENDS前面的“#”去掉。<br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service6.jpg" class=""><br>在如下位置进行配置，add_executable(client src/client.cpp)的作用是将src文件夹下的client.cpp文件编译成名为client的可执行文件。target_link_libraries(client ${catkin_LIBRARIES})的作用是将client可执行文件与ROS相关的库链接。add_dependencies(client ${PROJECT_NAME}_gencpp)的作用是将client可执行文件与一些动态生成的文件链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_executable(server src&#x2F;server.cpp)</span><br><span class="line">target_link_libraries(server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line"></span><br><span class="line">add_executable(client src&#x2F;client.cpp)</span><br><span class="line">target_link_libraries(client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(client $&#123;PROJECT_NAME&#125;_gencpp)</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service7.jpg" class=""></p>
<h3 id="3-2在package-xml中添加功能包依赖"><a href="#3-2在package-xml中添加功能包依赖" class="headerlink" title="3.2在package.xml中添加功能包依赖"></a>3.2在package.xml中添加功能包依赖</h3><p>打开功能包中的package.xml文件，在如下位置添加功能包依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service8.jpg" class=""><br>说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;buildtool_depend&gt;catkin&lt;&#x2F;buildtool_depend&gt;</span><br></pre></td></tr></table></figure><br>这条语句表示需要依赖catkin工具包用于使用catkin_make指令进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_export_depend&gt;roscpp&lt;&#x2F;build_export_depend&gt;</span><br></pre></td></tr></table></figure><br>这条语句表示编译后导出相关文件需要依赖roscpp功能包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;</span><br></pre></td></tr></table></figure><br>这条语句表示在编译时会依赖一个动态产生message的功能包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;</span><br></pre></td></tr></table></figure><br>这条语句表示在运行时会依赖message_runtime的功能包。</p>
<h3 id="3-3编译文件"><a href="#3-3编译文件" class="headerlink" title="3.3编译文件"></a>3.3编译文件</h3><p>在/ROS_ws文件夹路径下打开一个新的终端，输入以下代码进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service9.jpg" class=""><br>编译完成后，输入以下代码运行主节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service10.jpg" class=""><br>打开一个新的终端，配置环境变量后，输入以下代码运行节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun communication_pkg client 整数1 整数2</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service11.jpg" class=""><br>如果rosrun指令后面缺少需要相加的两个数，则会报如下错误。<br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service12.jpg" class=""><br>打开一个新的终端，配置环境变量后，输入以下代码运行节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun communication_pkg server</span><br></pre></td></tr></table></figure><br><img src="/2020/01/12/ROS%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/service13.jpg" class=""><br>若想停止运行，关闭终端，使用快捷键Ctrl+c即可</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chanchanchan97.github.io/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chan's Bloggerrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/" itemprop="url">ROS话题通信的编程实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-29T17:16:11+08:00">
                2019-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">ROS机器人操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-创建功能包"><a href="#1-创建功能包" class="headerlink" title="1.创建功能包"></a>1.创建功能包</h2><p>在ROS工作空间ROS_ws的src文件夹目录下创建一个功能包，命名为test_pkg，并编译完成。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic1.jpg" class=""></p>
<h2 id="2-节点编程与消息定义"><a href="#2-节点编程与消息定义" class="headerlink" title="2.节点编程与消息定义"></a>2.节点编程与消息定义</h2><h3 id="2-1案例说明"><a href="#2-1案例说明" class="headerlink" title="2.1案例说明"></a>2.1案例说明</h3><p>定义一个发布者Publisher，通过自定义的消息Person将消息数据name、sex及age等发送到订阅者Subscriber，同时订阅者将消息内容打印到终端界面。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic2.jpg" class=""></p>
<h3 id="2-2话题消息的定义"><a href="#2-2话题消息的定义" class="headerlink" title="2.2话题消息的定义"></a>2.2话题消息的定义</h3><p>在功能包目录下创建一个新的文件夹，命名为msg，并在此文件夹中创建一个空文件Person.msg。可以使用鼠标右键New Document&gt;Empty Document，或在src路径下通过终端命令符touch创建空文件。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic3.jpg" class=""><br>在Person.msg文件中输入以下代码，定义话题消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age  </span><br><span class="line"></span><br><span class="line">uint8 unknown &#x3D; 0</span><br><span class="line">uint8 male    &#x3D; 1</span><br><span class="line">uint8 female  &#x3D; 2</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3创建-cpp文件"><a href="#2-3创建-cpp文件" class="headerlink" title="2.3创建.cpp文件"></a>2.3创建.cpp文件</h3><p>在功能包下面的src文件夹目录下创建一个空文件Publisher_test.cpp。</p>
<h3 id="2-4话题发布者编程"><a href="#2-4话题发布者编程" class="headerlink" title="2.4话题发布者编程"></a>2.4话题发布者编程</h3><p>打开上述创建的文件Publisher_test，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros&#x2F;ros.h&quot;</span><br><span class="line">#include &quot;test_pkg&#x2F;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化ROS节点</span><br><span class="line">    ros::init(argc, argv, &quot;Publisher_test&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个发布者Publisher，发布名为&#x2F;person_info的topic，消息类型为test_pkg::Person，队列长度为10</span><br><span class="line">    ros::Publisher person_info_pub &#x3D; n.advertise&lt;test_pkg::Person&gt;(&quot;&#x2F;person_info&quot;, 10);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置消息发布频率</span><br><span class="line">    ros::Rate loop_rate(1);</span><br><span class="line"></span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while(ros::ok())</span><br><span class="line">    &#123;</span><br><span class="line">	&#x2F;&#x2F;初始化消息内容</span><br><span class="line">	test_pkg::Person person_msg;</span><br><span class="line">	person_msg.name &#x3D; &quot;Tom&quot;;</span><br><span class="line">	person_msg.age  &#x3D; 18;</span><br><span class="line">	person_msg.sex  &#x3D; test_pkg::Person::male;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;发布消息</span><br><span class="line">	person_info_pub.publish(person_msg);</span><br><span class="line">	</span><br><span class="line">	ROS_INFO(&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;,</span><br><span class="line">		  person_msg.name.c_str(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;按照设置的频率延时</span><br><span class="line">	loop_rate.sleep();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明：<br>◆头文件ros/ros.h包含了标准ROS类的声明，在每一个ROS程序中都需要包含它。<br>◆头文件test_pkg/Person.h是由Person.msg编译扩展得到，包含了针对C++类的定义等，它存放在工作空间的devel文件夹中。<br>◆main函数中ros::init(argc, argv, “Publisher_test”)的作用是初始化ROS节点，第三个参数表示节点名称，这个节点名是唯一的。<br>◆ros::NodeHandle n;的作用是创建句柄，启动ROS节点。<br>◆ros::Publisher person_info_pub = n.advertise<test_pkg::Person>(“/person_info”, 10);使用ros::Publisher类定义了一个发布者对象person_info_pub，发布的消息的数据类型为test_pkg::Person，用&lt;&gt;表示。/person_info表示发布消息数据的话题名，必须要与订阅者订阅的话题名相同。advertise()的第二个参数表示用于发布消息的消息队列长度，如果发布消息的速度快于底层响应的速度，则此处的数字指定在丢弃一些消息之前要缓冲多少条最新的消息。调用advertise()函数后，主节点（ROS Master）将通知任何试图订阅此话题名的节点，然后他们将与此节点协商对接。同时advertise()将返回一个Publisher对象，该对象使您可以通过调用publish()来发布有关该主题的消息。<br>◆ros::Rate loop_rate(1);的作用是设置消息发布频率为1Hz。<br>◆int count = 0;表明我们已发送多少条消息，用于为每个消息创建一个唯一的字符串。<br>◆若ros::ok()返回false，则可能发生了以下事件：<br>(1)SIGINT被触发(Ctrl-C)；<br>(2)被另一同名节点踢出 ROS 网络；<br>(3)ros::shutdown()被程序的另一部分调用；<br>(4)节点中的所有ros::NodeHandles 都已经被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_pkg::Person person_msg;</span><br><span class="line">person_msg.name &#x3D; &quot;Tom&quot;;</span><br><span class="line">person_msg.age  &#x3D; 18;</span><br><span class="line">person_msg.sex  &#x3D; test_pkg::Person::male;</span><br></pre></td></tr></table></figure><br>◆这部分的作用是对消息内容初始化，首先创建一个test_pkg::Person类的对象，之后设置这个对象中的name、age和sex。<br>◆person_info_pub.publish(person_msg);的作用是发布消息person_msg。<br>◆ROS_INFO()类似于C语言中的printf()函数，将内容打印在终端界面显示。<br>◆loop_rate.sleep();的作用是延时，以保证消息能够按照之前设置的发布频率发布出去。<br>综上所述，实现一个话题发布者的步骤大致可分为以下几点：<br>(1)初始化ROS节点；<br>(2)向ROS Master注册节点信息，包括发布的话题名和话题中的消息类型；<br>(3)按照一定频率循环发送消息。</p>
<h3 id="2-5话题订阅者编程"><a href="#2-5话题订阅者编程" class="headerlink" title="2.5话题订阅者编程"></a>2.5话题订阅者编程</h3><p>在src文件夹下再创建一个空文件Subscriber_test.cpp，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ros&#x2F;ros.h&quot;</span><br><span class="line">#include &quot;test_pkg&#x2F;Person.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;收到消息时进入回调函数</span><br><span class="line">void personInfoCallback(const test_pkg::Person::ConstPtr&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;打印消息</span><br><span class="line">    ROS_INFO(&quot;Subscribe Person Info: name:%s  age:%d  sex:%d&quot;,</span><br><span class="line">	      msg-&gt;name.c_str(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化ROS节点</span><br><span class="line">    ros::init(argc, argv, &quot;Subscriber_test&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个订阅者Subscriber</span><br><span class="line">    ros::Subscriber person_info_sub &#x3D; n.subscribe(&quot;&#x2F;person_info&quot;, 10, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;循环接收消息</span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明：<br>◆personInfoCallback(const test_pkg::Person::ConstPtr&amp; msg)是一个回调函数，一旦订阅者接收到消息，则执行该回调函数。在该回调函数中，打印消息内容name、age和sex。<br>◆main函数中一开始跟发布者一样，初始化ROS节点，创建句柄。<br>◆ros::Subscriber person_info_sub = n.subscribe(“/person_info”, 10, personInfoCallback);使用ros::Subscriber类定义一个订阅者对象person_info_sub。subscribe()函数中的第一个参数表示需要订阅的话题名，第二个参数表示消息队列的长度，如果消息到达的速度快于处理速度，则开始丢弃最旧的消息之前将被缓冲的消息数。subscribe()函数的第三个参数是回调函数名，消息被传递到回调函数。<br>◆ros::spin()在调用后不会再返回，也就是主程序到这儿就不往下执行了，一般放在main函数最后，而不放在while()循环里。<br>综上所述，实现一个话题订阅者的步骤大致可分为以下几点：<br>(1)初始化ROS节点；<br>(2)订阅需要的话题；<br>(3)循环等待话题消息，接收到消息后进入回调函数；<br>(4)在回调函数中完成消息处理。<br>附相关资料：<br>(1) <a href="http://wiki.ros.org/rospy/Overview/Publishers%20and%20Subscribers#Publisher.publish.28.29" target="_blank" rel="noopener">http://wiki.ros.org/rospy/Overview/Publishers%20and%20Subscribers#Publisher.publish.28.29</a><br>(2) <a href="http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29" target="_blank" rel="noopener">http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29</a></p>
<h2 id="3-配置与编译"><a href="#3-配置与编译" class="headerlink" title="3.配置与编译"></a>3.配置与编译</h2><h3 id="3-1在CMaKeLists-txt中添加编译选项"><a href="#3-1在CMaKeLists-txt中添加编译选项" class="headerlink" title="3.1在CMaKeLists.txt中添加编译选项"></a>3.1在CMaKeLists.txt中添加编译选项</h3><p>打开功能包中的CMaKeLists.txt文件。在如下位置的find_package中添加message_generation功能包，以便于（节点）调用它们生成消息。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic4.jpg" class=""><br>在如下位置添加相关的.msg文件，确保了CMake在重新配置时知道这些新添加的.msg文件，同时添加 .msg文件在生成消息时的所有依赖项（功能包）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(FILES Person.msg)</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs)</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic5.jpg" class=""><br>将如下位置中CATLIN_DEPENDS前面的“#”去掉。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic6.jpg" class=""><br>在如下位置进行配置，add_executable(Publisher_test src/Publisher_test.cpp)的作用是将src文件夹下的Publisher_test.cpp文件编译成名为Publisher_test的可执行文件。target_link_libraries(Publisher_test ${catkin_LIBRARIES})的作用是将Publisher_test可执行文件与ROS相关的库链接。add_dependencies(Publisher_test ${PROJECT_NAME}_generate_messages_cpp)的作用是将Publisher_test可执行文件与一些动态生成的文件链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_executable(Publisher_test src&#x2F;Publisher_test.cpp)</span><br><span class="line">target_link_libraries(Publisher_test $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(Publisher_test $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">add_executable(Subscriber_test src&#x2F;Subscriber_test.cpp)</span><br><span class="line">target_link_libraries(Subscriber_test $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(Subscriber_test $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic7.jpg" class=""></p>
<h3 id="3-2在package-xml中添加功能包依赖"><a href="#3-2在package-xml中添加功能包依赖" class="headerlink" title="3.2在package.xml中添加功能包依赖"></a>3.2在package.xml中添加功能包依赖</h3><p>打开功能包中的package.xml文件，在如下位置添加功能包依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic8.jpg" class=""><br>说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;</span><br></pre></td></tr></table></figure><br>这条语句表示在编译时会依赖一个动态产生message的功能包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;</span><br></pre></td></tr></table></figure><br>这条语句表示在运行时会依赖message_runtime的功能包。</p>
<h3 id="3-3编译文件"><a href="#3-3编译文件" class="headerlink" title="3.3编译文件"></a>3.3编译文件</h3><p>在/ROS_ws文件夹路径下打开一个新的终端，输入以下代码进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic9.jpg" class=""><br>编译完成后，输入以下代码运行主节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic10.jpg" class=""><br>打开一个新的终端，首先配置环境变量，然后输入以下代码运行节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun test_pkg Publisher_test</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic11.jpg" class=""><br>打开一个新的终端，首先配置环境变量，然后输入以下代码运行节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun test_pkg Subscriber_test</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic12.jpg" class=""><br>若想停止运行，关闭终端，使用快捷键Ctrl+c即可。</p>
<h2 id="4-话题可视化"><a href="#4-话题可视化" class="headerlink" title="4.话题可视化"></a>4.话题可视化</h2><p>打开一个新的终端，输入以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rqt_graph</span><br></pre></td></tr></table></figure><br>由此可以得到如下的基于Qt的GUI界面，直观地看到话题通信的发布订阅节点和消息。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic13.jpg" class=""></p>
<h2 id="5-rostopic命令的使用"><a href="#5-rostopic命令的使用" class="headerlink" title="5.rostopic命令的使用"></a>5.rostopic命令的使用</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic list</span><br></pre></td></tr></table></figure>
<p>使用上述指令能够列出所有当前正在订阅和发布的话题，效果如下图。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic14.jpg" class=""></p>
<h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic list -v</span><br></pre></td></tr></table></figure>
<p>使用上述指令能够得到当前正在订阅和发布的话题的详细内容介绍，效果如下图。<br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic15.jpg" class=""></p>
<h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><p>更多关于rostopic指令的使用，可以通过以下代码获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic --help</span><br></pre></td></tr></table></figure><br><img src="/2019/12/29/ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/topic16.jpg" class=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chanchanchan97.github.io/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chan's Bloggerrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/" itemprop="url">ROS工作空间及功能包的创建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-26T20:58:48+08:00">
                2019-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">ROS机器人操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h1><h2 id="1-1Ctrl-Alt-T打开一个新终端"><a href="#1-1Ctrl-Alt-T打开一个新终端" class="headerlink" title="1.1Ctrl + Alt + T打开一个新终端"></a>1.1Ctrl + Alt + T打开一个新终端</h2><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package1.JPG.jpg" class=""> 
<h2 id="1-2输入以下代码"><a href="#1-2输入以下代码" class="headerlink" title="1.2输入以下代码"></a>1.2输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~&#x2F;ROS_ws&#x2F;src</span><br></pre></td></tr></table></figure>
<p>说明：<br>mkdir是Linux命令，用于建立子目录。参数-p确保目录名称存在，不存在的就建一个。<br>这条语句的作用是在/home/用户名/下创建一个ROS工作空间，即文件夹ROS_ws。同时在工作空间ROS_ws下创建一个文件夹src。<br>你也可以将工作空间ROS_ws换成其他名字xxx，那么下面的所有命令中的ROS_ws都要对应换成xxx。<br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package2.JPG.jpg" class=""> </p>
<h2 id="1-3输入以下代码"><a href="#1-3输入以下代码" class="headerlink" title="1.3输入以下代码"></a>1.3输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;ROS_ws&#x2F;src</span><br></pre></td></tr></table></figure>
<p>说明：<br>进入工作空间ROS_ws下的文件夹src。<br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package3.JPG.jpg" class=""> </p>
<h2 id="1-4输入以下代码"><a href="#1-4输入以下代码" class="headerlink" title="1.4输入以下代码"></a>1.4输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_init_workspace</span><br></pre></td></tr></table></figure>
<p>说明：<br>对当前文件夹进行初始化，使它变成ROS的工作空间，同时src目录下会多出一个 CMakeLists.txt 文件。</p>
<h2 id="1-5输入以下代码"><a href="#1-5输入以下代码" class="headerlink" title="1.5输入以下代码"></a>1.5输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;ROS_ws</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..</span><br></pre></td></tr></table></figure><br>说明：<br>返回到上一级目录，即ROS_ws文件夹。</p>
<h2 id="1-6输入以下代码"><a href="#1-6输入以下代码" class="headerlink" title="1.6输入以下代码"></a>1.6输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make install</span><br></pre></td></tr></table></figure>
<p>说明：<br>对当前工作空间进行编译，编译完成后，工作空间ROS_ws中会再生成三个子目录：build、devel和install。</p>
<h1 id="2-创建功能包"><a href="#2-创建功能包" class="headerlink" title="2.创建功能包"></a>2.创建功能包</h1><h2 id="2-1输入以下代码"><a href="#2-1输入以下代码" class="headerlink" title="2.1输入以下代码"></a>2.1输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg test_pkg std_msgs roscpp rospy</span><br></pre></td></tr></table></figure>
<p>说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg &lt;功能包名称&gt; [依赖的功能包1] [依赖的功能包2]...</span><br></pre></td></tr></table></figure><br>这条语句的作用是创建功能包，代码语句的格式可参考上面。<br>test_pkg是功能包的名称，std_msgs、roscpp、rospy则是我们需要依赖的其他功能包。当我们使用C++或Python编写程序时，我们就需要依赖相关的库roscpp、rospy。我们在之后的例程中将运用到int、bool等消息类型，因此需要依赖相关的库std_msgs。</p>
<h2 id="2-2输入以下代码"><a href="#2-2输入以下代码" class="headerlink" title="2.2输入以下代码"></a>2.2输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;ROS_ws</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..</span><br></pre></td></tr></table></figure><br>说明：<br>返回到ROS_ws文件夹目录下。</p>
<h2 id="2-3输入以下代码"><a href="#2-3输入以下代码" class="headerlink" title="2.3输入以下代码"></a>2.3输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<p>说明：<br>对当前工作空间进行编译。</p>
<h2 id="2-4输入以下代码"><a href="#2-4输入以下代码" class="headerlink" title="2.4输入以下代码"></a>2.4输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source devel&#x2F;setup.bash</span><br></pre></td></tr></table></figure>
<p>说明：<br>将对应的工作空间的路径加入到环境变量ROS_PACKAGE_PATH中。有些电脑系统环境是zsh，则最后的.bash需要改成.zsh，可以通过如下语句查看当前环境设定的sh类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br></pre></td></tr></table></figure><br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package4.JPG.jpg" class=""><br>如果新开了一个终端命令行，在使用该工作空间前，必须先将该工作空间的路径加入环境变量ROS_PACKAGE_PATH中，否则无法运行功能包。要想避免反复设置环境变量带来的麻烦，可以按照如下步骤配置。</p>
<h3 id="2-4-1"><a href="#2-4-1" class="headerlink" title="2.4.1"></a>2.4.1</h3><p>进入主文件夹目录。<br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package5.JPG.jpg" class=""></p>
<h3 id="2-4-2"><a href="#2-4-2" class="headerlink" title="2.4.2"></a>2.4.2</h3><p>使用快捷键Ctrl + H，显示文件夹中的隐藏文件。<br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package6.JPG.jpg" class=""></p>
<h3 id="2-4-3"><a href="#2-4-3" class="headerlink" title="2.4.3"></a>2.4.3</h3><p>打开.bash文件，并拉到最后一行，添加如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source &#x2F;home&#x2F;用户名&#x2F;ROS_ws&#x2F;devel&#x2F;setup.bash</span><br></pre></td></tr></table></figure><br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package7.JPG.jpg" class=""></p>
<h2 id="2-5输入以下代码"><a href="#2-5输入以下代码" class="headerlink" title="2.5输入以下代码"></a>2.5输入以下代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $ROS_PACKAGE_PATH</span><br></pre></td></tr></table></figure>
<p>说明：<br>ROS_PACKAGE_PATH是ROS本身的环境变量，它会根据这个环境变量查找所有功能包的路径。如果打印出以下信息，说明你的工作环境设置好了。<br><img src="/2019/12/26/ROS%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA/package8.JPG.jpg" class=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chanchanchan97.github.io/2019/12/25/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chan's Bloggerrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%AE%80%E4%BB%8B/" itemprop="url">机器人操作系统（ROS）简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-25T13:20:43+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">ROS机器人操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-ROS基本概念"><a href="#1-ROS基本概念" class="headerlink" title="1.ROS基本概念"></a>1.ROS基本概念</h2><p>ROS Wiki对于机器人操作系统（ROS）的解释是：ROS是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。它的目的是为了提高机器人研发中的软件复用率，简化跨机器人平台创建复杂、鲁棒的机器人行为这一过程的难度与复杂度。<br><img src="/2019/12/25/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%AE%80%E4%BB%8B/ROS1.jpg" class=""><br>上图是ROS官方早期发布的一张图，简单定义了什么是ROS，即ROS是通讯机制、开发工具、应用功能以及生态系统的集合体，其中通信机制可以说是ROS的核心。</p>
<h2 id="2-ROS架构"><a href="#2-ROS架构" class="headerlink" title="2.ROS架构"></a>2.ROS架构</h2><img src="/2019/12/25/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%AE%80%E4%BB%8B/ROS2.jpg" class="">
<h3 id="2-1OS层"><a href="#2-1OS层" class="headerlink" title="2.1OS层"></a>2.1OS层</h3><p>ROS并非像Windows、Linux等传统意义上的操作系统，无法直接运行在计算机硬件上，因此它需要依赖于Linux系统。</p>
<h3 id="2-2中间层"><a href="#2-2中间层" class="headerlink" title="2.2中间层"></a>2.2中间层</h3><p>Linux系统本身没有针对机器人开发的中间件，因此ROS在中间层做了大量工作。首先是基于TCP/UDP网络，并在此之上进一步封装而构建的TCPROS/UDPROS通信系统。另外ROS还提供了一种进程内的通信方法——Nodelet，为多进程通信提供了一种更为优化的数据传输方式。在通信机制之上，ROS提供了大量机器人开发的库，以提供给应用层调用。</p>
<h2 id="2-3应用层"><a href="#2-3应用层" class="headerlink" title="2.3应用层"></a>2.3应用层</h2><p>应用层中ROS需要一个管理者——Master，负责管理整个系统正常运行，为节点间建立连接。</p>
<h2 id="3-通信机制"><a href="#3-通信机制" class="headerlink" title="3.通信机制"></a>3.通信机制</h2><p>ROS采用的是一种点对点的分布式通信机制，实现模块间点对点的松耦合连接，所有软件功能及工具都建立在这种通信机制上，为用户提供多节点（进程）的通信服务，其中ROS最核心的三种通信机制是话题（Topic）通信机制、服务（Service）通信机制和参数（Parameter）管理机制。</p>
<h2 id="4-计算图"><a href="#4-计算图" class="headerlink" title="4.计算图"></a>4.计算图</h2><p>ROS系统的功能模块以节点为单位单独运行，可以分布于多个不同或相同的主机中，通过端对端的拓扑结构相连接。<br><img src="/2019/12/25/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88ROS%EF%BC%89%E7%AE%80%E4%BB%8B/ROS3.jpg" class=""></p>
<h3 id="4-1节点（Node）"><a href="#4-1节点（Node）" class="headerlink" title="4.1节点（Node）"></a>4.1节点（Node）</h3><p>节点就是执行具体任务的进程或独立运行的可执行文件，通常一个系统由多个节点组成，节点之间可以通过 ROS 客户端库（如roscpp 、rospy）相互通信。不同节点可使用不同编程语言，可分布式运行在不同的主机。节点在系统中的名称必须是唯一的。</p>
<h3 id="4-2节点管理器（Master）"><a href="#4-2节点管理器（Master）" class="headerlink" title="4.2节点管理器（Master）"></a>4.2节点管理器（Master）</h3><p>节点管理器在系统中主要起到了一个中介的作用，能够帮助节点相互找到彼此。节点管理器能够为节点提供命名和注册服务，以及跟踪和记录话题/服务通信。同时节点管理器还提供了一个参数服务器（Parameter Server），节点使用此服务器存储和检索运行时的参数。</p>
<h3 id="4-3消息（Message）"><a href="#4-3消息（Message）" class="headerlink" title="4.3消息（Message）"></a>4.3消息（Message）</h3><p>消息本身是基于发布/订阅模型的话题通信机制而来的，具有一定的类型和数据结构，既包含ROS提供的标准数据类型，也可由用户自定义数据类型。</p>
<h3 id="4-4话题（Topic）"><a href="#4-4话题（Topic）" class="headerlink" title="4.4话题（Topic）"></a>4.4话题（Topic）</h3><p>话题通信采用的是一种异步通信机制。话题通信基于发布/订阅模型，数据由发布者传输给订阅者。其中节点既可以作为发布者发布消息，也可以作为订阅者订阅消息。同一个话题的发布者和订阅者可以不唯一，另外一个节点也可以发布或订阅多个消息。一般来说，发布者和订阅者并不知道对方的存在。发布者将信息发布在一个全局的工作区内，当订阅者发现该信息是它所订阅的，就可以接收到这个信息。通常用于数据传输。</p>
<h3 id="4-5服务（Service）"><a href="#4-5服务（Service）" class="headerlink" title="4.5服务（Service）"></a>4.5服务（Service）</h3><p>服务通信采用的是一种同步通信机制。服务通信基于客户端/服务器模型，客户端（Client）发送请求数据（Request），服务器（Server）完成处理后返回应答数据（Response）。与话题不同的是，ROS中只允许有一个节点提供指定命名的服务。通常用于逻辑处理。</p>
<h3 id="4-6动作（Action）"><a href="#4-6动作（Action）" class="headerlink" title="4.6动作（Action）"></a>4.6动作（Action）</h3><p>动作是基于ROS消息机制实现的一种问答通信机制，基于客户端/服务器模型，服务器可以连续反馈数据给客户端，客户端可以在任务运行过程中中止运行。动作Action的接口主要由goal、cancel、status、feedback和result组成，客户端可以在任务启动前向服务器发布任务目标goal，也可以在任务过程中向服务器发送cancel请求取消任务。服务器向客户端反馈服务器当前的状态，或周期性反馈任务运行的监控数据，而result在任务运行过程中只发布一次，仅在服务器完成动作后反馈一个最终结果。</p>
<h3 id="4-7消息记录包（Bag）"><a href="#4-7消息记录包（Bag）" class="headerlink" title="4.7消息记录包（Bag）"></a>4.7消息记录包（Bag）</h3><p>消息记录包是一种用于保存和回放 ROS 消息数据的文件格式。它使用.bag格式保存消息、主题、服务和其他ROS数据信息，可以在事件发生后，通过使用可视化工具调用和回放数据，检查在系统中到底发生了什么。记录包文件可以像实时会话一样在ROS中再现情景，在相同时间向主题发送相同的数据。通常用于调试算法。</p>
<h3 id="4-8参数（Parameter）"><a href="#4-8参数（Parameter）" class="headerlink" title="4.8参数（Parameter）"></a>4.8参数（Parameter）</h3><p>参数服务器能够保存一部分参数作为全局共享字典，系统中的所有节点都可以通过网络访问这些共享字典，存储和检索参数的参数名或参数值，而字典中的数据类型包含了int整型、float浮点型、string字符串等。参数的存储和检索采用的通信机制是更为底层的RPC，而不再是话题或服务。它更适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。</p>
<h3 id="4-9功能包（Package）"><a href="#4-9功能包（Package）" class="headerlink" title="4.9功能包（Package）"></a>4.9功能包（Package）</h3><p>功能包是ROS软件中的基本单元，包含节点源码、配置文件、数据定义等。</p>
<h3 id="4-10功能包清单（Package-manifest）"><a href="#4-10功能包清单（Package-manifest）" class="headerlink" title="4.10功能包清单（Package manifest）"></a>4.10功能包清单（Package manifest）</h3><p>功能包清单记录了功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p>
<h3 id="4-11元功能包（Meta-Package）"><a href="#4-11元功能包（Meta-Package）" class="headerlink" title="4.11元功能包（Meta Package）"></a>4.11元功能包（Meta Package）</h3><p>元功能包是一种特殊的功能包，它只包含元功能包清单文件。它的作用是将多个具有相同功能的功能包整合成一个逻辑上独立的功能包，类似于功能包集合。</p>
<h2 id="5-开源社区"><a href="#5-开源社区" class="headerlink" title="5.开源社区"></a>5.开源社区</h2><p>ROS开源社区级主要关于ROS资源，能够通过独立的网络社区分享软件和知识。这些资源包括：<br>发行版（Distribution）—— ROS发行版是可以独立安装的，带有版本号的一系列功能包集。ROS发行版像Linux发行版一样发挥类似的作用。这使得ROS软件安装更加容易，而且能够通过一个软件集合来维持一致的版本。<br>软件源(Repositorie)—— ROS依赖于共享开源代码与软件源的网站或主机服务，在这里不同的机构能够发布分享各自的机器人软件和程序。<br>ROS Wiki—— ROS Wiki是用于记录有关ROS系统信息的主要论坛。任何人都可以注册账户和贡献自己的文件，提供更正和更新，编写教程以及其他信息。<br>邮件列表(Mailing list)—— ROS用户邮件列表是关于ROS的主要交流渠道，能够交流从ROS软件更新到ROS软件使用中的各种疑问或信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chanchanchan97.github.io/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chan's Bloggerrrrr">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/" itemprop="url">第十三届“恩智浦”杯全国大学生智能汽车竞赛-信标对抗组比赛总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T19:58:01+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%99%BA%E8%83%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index">
                    <span itemprop="name">智能车竞赛</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、比赛形式"><a href="#一、比赛形式" class="headerlink" title="一、比赛形式"></a>一、比赛形式</h2><p>信标对抗组是让小车通过摄像头识别信标位置，并驶向闪烁的信标，借助磁铁切割磁感线从而熄灭信标。</p>
<h2 id="二、主控板电源电路"><a href="#二、主控板电源电路" class="headerlink" title="二、主控板电源电路"></a>二、主控板电源电路</h2><h3 id="1-DC-DC稳压电路（6-8V-8-4V稳压到6V）"><a href="#1-DC-DC稳压电路（6-8V-8-4V稳压到6V）" class="headerlink" title="1.DC-DC稳压电路（6.8V-8.4V稳压到6V）"></a>1.DC-DC稳压电路（6.8V-8.4V稳压到6V）</h3><h4 id="1-1电路原理图："><a href="#1-1电路原理图：" class="headerlink" title="1.1电路原理图："></a>1.1电路原理图：</h4><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar1.jpg" class="">
<h4 id="1-2稳压芯片TPS565201热仿真（输入电压8-4V，输出电压6V，电流4A）："><a href="#1-2稳压芯片TPS565201热仿真（输入电压8-4V，输出电压6V，电流4A）：" class="headerlink" title="1.2稳压芯片TPS565201热仿真（输入电压8.4V，输出电压6V，电流4A）："></a>1.2稳压芯片TPS565201热仿真（输入电压8.4V，输出电压6V，电流4A）：</h4><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar2.jpg" class="">
<p>仿真结果参数：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar3.jpg" class=""></p>
<h4 id="1-3稳压芯片TPS565201输出电流电压波形仿真（电压在0-05V左右波动）："><a href="#1-3稳压芯片TPS565201输出电流电压波形仿真（电压在0-05V左右波动）：" class="headerlink" title="1.3稳压芯片TPS565201输出电流电压波形仿真（电压在0.05V左右波动）："></a>1.3稳压芯片TPS565201输出电流电压波形仿真（电压在0.05V左右波动）：</h4><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar4.jpg" class="">
<h3 id="2-线性稳压电路（6-8V-8-4V稳压到5V）"><a href="#2-线性稳压电路（6-8V-8-4V稳压到5V）" class="headerlink" title="2.线性稳压电路（6.8V-8.4V稳压到5V）"></a>2.线性稳压电路（6.8V-8.4V稳压到5V）</h3><h4 id="2-1电路原理图："><a href="#2-1电路原理图：" class="headerlink" title="2.1电路原理图："></a>2.1电路原理图：</h4><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar5.jpg" class="">
<h4 id="2-2线性稳压芯片LMS1585A输出电流电压波形仿真（输入电压7-6V，输出电压5V，电流1A）："><a href="#2-2线性稳压芯片LMS1585A输出电流电压波形仿真（输入电压7-6V，输出电压5V，电流1A）：" class="headerlink" title="2.2线性稳压芯片LMS1585A输出电流电压波形仿真（输入电压7.6V，输出电压5V，电流1A）："></a>2.2线性稳压芯片LMS1585A输出电流电压波形仿真（输入电压7.6V，输出电压5V，电流1A）：</h4><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar6.jpg" class="">
<h2 id="三、控制逻辑及策略"><a href="#三、控制逻辑及策略" class="headerlink" title="三、控制逻辑及策略"></a>三、控制逻辑及策略</h2><h3 id="1-主程序框架："><a href="#1-主程序框架：" class="headerlink" title="1.主程序框架："></a>1.主程序框架：</h3><p>通过switch-case语句实现状态机编程。为了增加可读性，采用枚举的方式表示各状态（如下图）。<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar7.jpg" class=""></p>
<h3 id="2-控制部分"><a href="#2-控制部分" class="headerlink" title="2.控制部分"></a>2.控制部分</h3><h4 id="2-1双电机后轮差速：阿克曼转向模型"><a href="#2-1双电机后轮差速：阿克曼转向模型" class="headerlink" title="2.1双电机后轮差速：阿克曼转向模型"></a>2.1双电机后轮差速：阿克曼转向模型</h4><p>2.1.1理论模型：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar8.jpg" class=""></p>
<p>2.1.2公式推导：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar9.jpg" class=""></p>
<p>2.1.3算法实现：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar10.jpg" class=""></p>
<h4 id="2-2接近信标策略：采用舵机PD控制-参数查表法沿信标灯切线方向灭灯。"><a href="#2-2接近信标策略：采用舵机PD控制-参数查表法沿信标灯切线方向灭灯。" class="headerlink" title="2.2接近信标策略：采用舵机PD控制+参数查表法沿信标灯切线方向灭灯。"></a>2.2接近信标策略：采用舵机PD控制+参数查表法沿信标灯切线方向灭灯。</h4><p>首先沿着期望的路径手推小车，并将信标的横坐标、纵坐标和宽度通过蓝牙发送到上位机，储存在Excel文件中，所得到的横坐标作为期望横坐标。以图像中的实际横坐标作为反馈，输入量为期望横坐标，输出量为控制舵机角度的PWM波。期望横坐标与图像宽度、纵坐标通过查表法建立一一对应的关系，缺点是一旦改变阈值，图像宽度改变，需要修改的参数较多。原先通过MATLAB对采集到的数据进行拟合，但是发现有些地方数据较分散，找不到合适的拟合函数，所以改用查表法。<br>曲线拟合结果（横坐标-信标宽度，纵坐标-信标中心点的横坐标）：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar11.jpg" class=""></p>
<p>在之后的国赛中为了解决利用信标宽度作为PID模型输入值的缺点，我们改用信标的纵坐标，这样可以避免因调节阈值而反复修改PID参数和输入的期望值。  </p>
<h4 id="2-3图像补偿"><a href="#2-3图像补偿" class="headerlink" title="2.3图像补偿"></a>2.3图像补偿</h4><p>由于今年规则中信标灯的红外发射频率变为10HZ，实际中会出现50ms的无图像，造成舵机频繁抖舵，严重情况下会因电流过大而烧坏舵机的稳压芯片。省赛中使用80×60的分辨率，摄像头帧率合适，抖舵影响不大，所以没有做图像补偿。但是分辨率改成160×120之后，帧率只有50帧/秒，抖舵现象严重，并且经常因为图像丢失而开始自转寻找目标。<br>横坐标补偿算法：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar12.jpg" class=""></p>
<p>纵坐标补偿算法：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar13.jpg" class=""></p>
<p>图像补偿效果（蓝色为离散的原始数据，红色为连续的补偿数据）：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar14.jpg" class=""></p>
<h3 id="3-图像识别部分"><a href="#3-图像识别部分" class="headerlink" title="3.图像识别部分"></a>3.图像识别部分</h3><h4 id="3-1摄像头型号：山外鹰眼硬件二值化摄像头"><a href="#3-1摄像头型号：山外鹰眼硬件二值化摄像头" class="headerlink" title="3.1摄像头型号：山外鹰眼硬件二值化摄像头"></a>3.1摄像头型号：山外鹰眼硬件二值化摄像头</h4><p>山外鹰眼摄像头其本身已经做了硬件二值化，直接得到黑白图像，好处是减轻了主控芯片进行软件二值化的运算压力，提升了运算效率，但是坏处是只能对黑白图像做处理，容易受到环境干扰。</p>
<h4 id="3-2图像的存储与压缩"><a href="#3-2图像的存储与压缩" class="headerlink" title="3.2图像的存储与压缩"></a>3.2图像的存储与压缩</h4><p>由于山外摄像头读取到的图像只有黑色和白色，所以在数组中只需要用0和1来表示。山外官方的代码中将八个像素放入一个字节中，因此分辨率60<em>80的图像只需要用60</em>80/8=600大小的数组存放。</p>
<h4 id="3-3图像横、纵坐标的计算"><a href="#3-3图像横、纵坐标的计算" class="headerlink" title="3.3图像横、纵坐标的计算"></a>3.3图像横、纵坐标的计算</h4><p>一张图像有60行80列，信标在图像中是0，其它地方是1，所以将每一行的80个像素相加求和，和最小的那一行可以看做是信标的纵坐标，同理和最小的那一列可以看做是信标的横坐标。</p>
<h4 id="3-4图像滤波"><a href="#3-4图像滤波" class="headerlink" title="3.4图像滤波"></a>3.4图像滤波</h4><p>由于鹰眼摄像头输出的只有黑白二值化图像，只能通过遍历数组寻找离散的点进行简单的滤波。<br>图像滤波算法：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar15.jpg" class=""></p>
<h4 id="3-5创新点：侧面摄像头辅助判断转弯方向。"><a href="#3-5创新点：侧面摄像头辅助判断转弯方向。" class="headerlink" title="3.5创新点：侧面摄像头辅助判断转弯方向。"></a>3.5创新点：侧面摄像头辅助判断转弯方向。</h4><p>由于比赛中熄灭一盏信标灯之后，下一盏信标灯的位置是随机的，如果采用固定的转弯方向会导致绕远路而浪费时间，因此我们采用双摄像头辅助定位。省赛前因为图像分辨率都80×60，所以采用单核双摄的方案主控芯片也能带的动。但是国赛改用160×120的分辨率之后，第二个摄像头无法正常工作，于是改用双核双摄的方案，其中两块芯片之间通过串口通信。<br>实现方式是前面的摄像头为主摄像头，用于正常寻找目标并反馈给控制系统。当前面的摄像头没有捕捉到图像时，判断右边的摄像头得到的数据，如果右边摄像头有图像，则往右转，反之往左转。<br>双摄像头摆放位置如下图：<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar16.jpg" class=""></p>
<h3 id="4-调试界面部分"><a href="#4-调试界面部分" class="headerlink" title="4.调试界面部分"></a>4.调试界面部分</h3><h4 id="4-1摄像头图像显示"><a href="#4-1摄像头图像显示" class="headerlink" title="4.1摄像头图像显示"></a>4.1摄像头图像显示</h4><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar17.jpg" class="">
<h4 id="4-2当前状态信息显示"><a href="#4-2当前状态信息显示" class="headerlink" title="4.2当前状态信息显示"></a>4.2当前状态信息显示</h4><p>由上至下分别为：横坐标、纵坐标、图像宽度、当前工作模式、左轮速度、右轮速度、横坐标期望值。<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar18.jpg" class=""></p>
<h4 id="4-3主要参数显示和调试"><a href="#4-3主要参数显示和调试" class="headerlink" title="4.3主要参数显示和调试"></a>4.3主要参数显示和调试</h4><p>由上至下分别为：直线速度期望值、舵机中值、舵机PID模型比例系数、舵机PID模型积分系数、舵机PID模型微分系数、正常模式/调试模式、转弯速度期望值。<br><img src="/2019/12/19/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E6%9D%AF%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B%E4%BF%A1%E6%A0%87%E5%AF%B9%E6%8A%97%E7%BB%84%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/smartcar19.jpg" class=""></p>
<h2 id="四、比赛经验总结"><a href="#四、比赛经验总结" class="headerlink" title="四、比赛经验总结"></a>四、比赛经验总结</h2><p>1.摄像头焦距需要调节到合适位置，否则能看到近距离的目标但是看不到远距离的目标或者能看到远距离的目标而近距离目标模糊，所以调节焦距使得最大距离的图像以及最近距离的图像都能较为清晰。 </p>
<p>2.经典控制理论是基于刚性模型所建立，而实际上我们通常所遇到的例如智能车的结构都是柔性结构，结构之间存在柔性间隙以及谐振等，所以我们在小车前端的舵机连杆以及减震结构中加入黄油，堵住间隙又能起到润滑效果。</p>
<p>3.单片机超频之后耗电会加快。</p>
<p>4.6v/250A船型开关使用一段时间后会出现问题，导致电池电压经过开关之后降压。</p>
<p>5.pwm频率对发热有影响。频率太低，电机外壳会产生涡流。</p>
<p>6.使用BTN作为电机驱动芯片，允许通过的最大电流较低，容易烧芯片，尤其是B车电机动力大，驱动电流较大。mos管允许通过的电流值较大，但是一个电机需要四个mos管组成一个全桥电路驱动，一个BTN相当于一个半桥。</p>
<p>7.电机和舵机控制放在定时器中断中。电机控制频率1khz，定时周期1ms。舵机控制频率100hz，定时周期10ms。电机和舵机如果同时放在一个1ms定时器里面，每进一次中断变量自加一，加到10的时候，执行舵机控制程序，中间可能会被其它中断打断，而使得中断里面没有按照10ms的周期控制舵机。所以电机和舵机尽量放在两个定时器中断里面。实时性高的程序放进中断里。</p>
<p>8.PID实时调参方法：设置三个电位器，通过调节电位器旋钮，改变PID三个参数Kp、Ki、Kd，并通过无线模块将参数实时发送给小车，同时接收小车速度信息，将速度波形显示在电脑上。</p>
<p>9.在车底铺满铝箔可以有效减少小车运行过程中产生的静电。</p>
<p>10.减少部分杂光干扰的方法：<br>①使用偏振片。<br>②将摄像头架高。<br>③镜头采用平光镜。</p>
<p>11.降压芯片压差过大会导致芯片工作功率增大而发烫。</p>
<p>12.ABS制动防抱死系统：每秒制动8次左右，让轮胎边滚边滑。</p>
<p>13.Matlab数据拟合工具箱cftool。</p>
<p>14.LSD限滑：两侧驱动轮转速差值被允许在一定范围内，以保证正常的转弯等行驶性能。</p>
<p>15.没有坑纹的光头胎相比有坑纹的轮胎，在干地上能提供更多的摩擦力（接触面积越大，摩擦力越大），更多的摩擦力意味着更强的抓地力，更强的抓地力意味着赛车尤其是在弯道中就能有更快的车速。<br>相关资料：<br><a href="https://www.zhihu.com/question/23747154/answer/257882068?utm_source=qq&amp;utm_medium=social" target="_blank" rel="noopener">https://www.zhihu.com/question/23747154/answer/257882068?utm_source=qq&amp;utm_medium=social</a></p>
<p>16.F1赛车弯道转向相关资料：<br><a href="https://www.guokr.com/post/691728/focus/0345131746/" target="_blank" rel="noopener">https://www.guokr.com/post/691728/focus/0345131746/</a></p>
<p>17.增大轮胎摩擦力的各种方法（主要针对B车轮胎）：<br>①在轮胎里面垫海绵，使得轮胎膨胀起来一点。<br>②先将轮胎密封，然后用注射筒向轮胎内充气。<br>③使用细砂纸将轮胎磨平（规则不允许），增大受力面积，或者将轮胎磨粗糙。<br>④涂软化剂。<br>⑤新C车轮胎需要多跑跑可以有助于磨轮胎。<br>⑥松香磨成粉溶解在酒精里，然后涂轮胎上。</p>
<p>18.广角镜镜头角度越大，镜头中的红外图像就越小。对于鹰眼硬件二值化摄像头，可以通过提高阈值和提高分辨率使得图像更大，但是分辨率提高之后CPU负载大，摄像头帧率会下降。</p>
<p>19.信标组推荐芯片及摄像头：K66+总钻风<br>推荐识别方案：图像分割、识别颜色；<br>推荐避障方案：线性CCD、摄像头。</p>
<p>20.新C车比旧C车容易打滑。</p>
<p>21.防止轮胎与轮毂分离可以采用704硅胶涂抹在轮胎与轮毂贴合处。</p>
<p>22.DC-DC电路线性稳压效率高。</p>
<h2 id="五、比赛视频"><a href="#五、比赛视频" class="headerlink" title="五、比赛视频"></a>五、比赛视频</h2><video width="820" height="464" controls>
<source src="smartcar_NXP.mp4">
</video>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
